cv[i] <- cn
isseed[i] <- TRUE
reachables <- setdiff(reachables, i)
unclass <- setdiff(unclass, i)
classn[reachables] <- classn[reachables] + 1
while (length(reachables)) {
cv[reachables] <- cn
ap <- reachables
reachables <- integer()
for (i2 in seq(along = ap)) {
j <- ap[i2]
jreachables <- intersect(unclass[data_spasial[j, unclass] <= eps], unclass[data_temporal[j, unclass] <= eps2])
if (length(jreachables) + classn[j] >= minpts) {
isseed[j] <- TRUE
cv[jreachables[cv[jreachables] < 0]] <- cn
reachables <- union(reachables, jreachables[cv[jreachables] == 0])
}
classn[jreachables] <- classn[jreachables] + 1
unclass <- setdiff(unclass, j)
}
}
}
}
if (!length(unclass))
break
}
rm(classn)    #Remove classn
if (any(cv == (-1))) {
cv[cv == (-1)] <- 0
}
out <- list(cluster = cv, eps = eps, minpts = minpts)
if (seeds && cn > 0) {
out$isseed <- isseed
}
class(out) <- "stdbscan"
clusterid <- as.matrix(out$cluster)
clusterid
}
stdbscan(data=data, eps=10, eps2=20)
stdbscan = function (data, eps, eps2, minpts = 10, seeds = TRUE, countmode = 1:nrow(data)) {
# Calculates the spatial distance between pairs of observations. Essentially, if the data set has
# n observations, we get a symmetric n x n matrix, where each entry (i,j) = (j,i) is the distance
# between observations i and j.
data_spasial<- dist(cbind(data$latitude,data$longitude))
# Calculates the temporal distance (i.e., time) between pairs of observations. Essentially, if the
# data set has n observations, we get a symmetric n x n matrix, where each entry (i,j) = (j,i) is
# the distance between observations i and j.
data_temporal<- dist(data$date)
# Storing bboth data_spasial and data_temporal as matrices
data_spasial <- as.matrix(data_spasial)
data_temporal <- as.matrix(data_temporal)
# Identifying how many observations we have
n <- nrow(data_spasial)
# Here, we are assigning the types of each output value.
# Both classn and cv will be integer vectors of size n.
classn <- cv <- integer(n)
# On the other hand, isseed will be a logical vector (true/false) of size n
isseed <- logical(n)
# Lastly, cn will be a vector with a single integer element.
cn <- integer(1)
# For each observation i for i = 1 to i = n, we do the following:
for (i in 1:n) {
#This next line seems redundant: if i is in vector countmode (i.e., i..n)
if (i %in% countmode)
#cat("Processing point ", i, " of ", n, ".\n")
unclass <- (1:n)[cv < 1]
if (cv[i] == 0) {
reachables <- intersect(unclass[data_spasial[i, unclass] <= eps],  unclass[data_temporal[i, unclass] <= eps2])
if (length(reachables) + classn[i] < minpts)
cv[i] <- (-1)
else {
cn <- cn + 1
cv[i] <- cn
isseed[i] <- TRUE
reachables <- setdiff(reachables, i)
unclass <- setdiff(unclass, i)
classn[reachables] <- classn[reachables] + 1
while (length(reachables)) {
cv[reachables] <- cn
ap <- reachables
reachables <- integer()
for (i2 in seq(along = ap)) {
j <- ap[i2]
jreachables <- intersect(unclass[data_spasial[j, unclass] <= eps], unclass[data_temporal[j, unclass] <= eps2])
if (length(jreachables) + classn[j] >= minpts) {
isseed[j] <- TRUE
cv[jreachables[cv[jreachables] < 0]] <- cn
reachables <- union(reachables, jreachables[cv[jreachables] == 0])
}
classn[jreachables] <- classn[jreachables] + 1
unclass <- setdiff(unclass, j)
}
}
}
}
if (!length(unclass))
break
}
rm(classn)    #Remove classn
if (any(cv == (-1))) {
cv[cv == (-1)] <- 0
}
out <- list(cluster = cv, eps = eps, minpts = minpts)
if (seeds && cn > 0) {
out$isseed <- isseed
}
class(out) <- "stdbscan"
clusterid <- as.matrix(out$cluster)
return(clusterid)
}
stdbscan(data=data, eps=10, eps2=20)
stdbscan = function (data, eps, eps2, minpts = 10, seeds = TRUE, countmode = 1:nrow(data)) {
# Calculates the spatial distance between pairs of observations. Essentially, if the data set has
# n observations, we get a symmetric n x n matrix, where each entry (i,j) = (j,i) is the distance
# between observations i and j.
data_spasial<- dist(cbind(data$latitude,data$longitude))
# Calculates the temporal distance (i.e., time) between pairs of observations. Essentially, if the
# data set has n observations, we get a symmetric n x n matrix, where each entry (i,j) = (j,i) is
# the distance between observations i and j.
data_temporal<- dist(data$date)
# Storing bboth data_spasial and data_temporal as matrices
data_spasial <- as.matrix(data_spasial)
data_temporal <- as.matrix(data_temporal)
# Identifying how many observations we have
n <- nrow(data_spasial)
# Here, we are assigning the types of each output value.
# Both classn and cv will be integer vectors of size n.
classn <- cv <- integer(n)
# On the other hand, isseed will be a logical vector (true/false) of size n
isseed <- logical(n)
# Lastly, cn will be a vector with a single integer element.
cn <- integer(1)
# For each observation i for i = 1 to i = n, we do the following:
for (i in 1:n) {
#This next line seems redundant: if i is in vector countmode (i.e., i..n)
if (i %in% countmode)
#cat("Processing point ", i, " of ", n, ".\n")
unclass <- (1:n)[cv < 1]
if (cv[i] == 0) {
reachables <- intersect(unclass[data_spasial[i, unclass] <= eps],  unclass[data_temporal[i, unclass] <= eps2])
if (length(reachables) + classn[i] < minpts)
cv[i] <- (-1)
else {
cn <- cn + 1
cv[i] <- cn
isseed[i] <- TRUE
reachables <- setdiff(reachables, i)
unclass <- setdiff(unclass, i)
classn[reachables] <- classn[reachables] + 1
while (length(reachables)) {
cv[reachables] <- cn
ap <- reachables
reachables <- integer()
for (i2 in seq(along = ap)) {
j <- ap[i2]
jreachables <- intersect(unclass[data_spasial[j, unclass] <= eps], unclass[data_temporal[j, unclass] <= eps2])
if (length(jreachables) + classn[j] >= minpts) {
isseed[j] <- TRUE
cv[jreachables[cv[jreachables] < 0]] <- cn
reachables <- union(reachables, jreachables[cv[jreachables] == 0])
}
classn[jreachables] <- classn[jreachables] + 1
unclass <- setdiff(unclass, j)
}
}
}
}
if (!length(unclass))
break
}
rm(classn)    #Remove classn
if (any(cv == (-1))) {
cv[cv == (-1)] <- 0
}
out <- list(cluster = cv, eps = eps, minpts = minpts)
if (seeds && cn > 0) {
out$isseed <- isseed
}
class(out) <- "stdbscan"
clusterid <- as.matrix(out$cluster)
data <-cbind(data, clusterid)
return(clusterid)
}
stdbscan(data=data, eps=10, eps2=20)
stdbscan(data=data, eps=10, eps2=5)
stdbscan(data=data, eps=1, eps2=5)
stdbscan(data=data, eps=1, eps2=3)
data <- read.csv("data.csv")
head(data)
stdbscan = function (data, eps, eps2, minpts = 10, seeds = TRUE, countmode = 1:nrow(data)) {
# Calculates the spatial distance between pairs of observations. Essentially, if the data set has
# n observations, we get a symmetric n x n matrix, where each entry (i,j) = (j,i) is the distance
# between observations i and j.
data_spasial<- dist(cbind(data$latitude,data$longitude))
# Calculates the temporal distance (i.e., time) between pairs of observations. Essentially, if the
# data set has n observations, we get a symmetric n x n matrix, where each entry (i,j) = (j,i) is
# the distance between observations i and j.
data_temporal<- dist(data$date)
# Storing bboth data_spasial and data_temporal as matrices
data_spasial <- as.matrix(data_spasial)
data_temporal <- as.matrix(data_temporal)
# Identifying how many observations we have
n <- nrow(data_spasial)
# Here, we are assigning the types of each output value.
# Both classn and cv will be integer vectors of size n.
classn <- cv <- integer(n)
# On the other hand, isseed will be a logical vector (true/false) of size n
isseed <- logical(n)
# Lastly, cn will be a vector with a single integer element.
cn <- integer(1)
# For each observation i for i = 1 to i = n, we do the following:
for (i in 1:n) {
#This next line seems redundant: if i is in vector countmode (i.e., i..n)
if (i %in% countmode)
#cat("Processing point ", i, " of ", n, ".\n")
unclass <- (1:n)[cv < 1]
if (cv[i] == 0) {
reachables <- intersect(unclass[data_spasial[i, unclass] <= eps],  unclass[data_temporal[i, unclass] <= eps2])
if (length(reachables) + classn[i] < minpts)
cv[i] <- (-1)
else {
cn <- cn + 1
cv[i] <- cn
isseed[i] <- TRUE
reachables <- setdiff(reachables, i)
unclass <- setdiff(unclass, i)
classn[reachables] <- classn[reachables] + 1
while (length(reachables)) {
cv[reachables] <- cn
ap <- reachables
reachables <- integer()
for (i2 in seq(along = ap)) {
j <- ap[i2]
jreachables <- intersect(unclass[data_spasial[j, unclass] <= eps], unclass[data_temporal[j, unclass] <= eps2])
if (length(jreachables) + classn[j] >= minpts) {
isseed[j] <- TRUE
cv[jreachables[cv[jreachables] < 0]] <- cn
reachables <- union(reachables, jreachables[cv[jreachables] == 0])
}
classn[jreachables] <- classn[jreachables] + 1
unclass <- setdiff(unclass, j)
}
}
}
}
if (!length(unclass))
break
}
rm(classn)    #Remove classn
if (any(cv == (-1))) {
cv[cv == (-1)] <- 0
}
out <- list(cluster = cv, eps = eps, minpts = minpts)
if (seeds && cn > 0) {
out$isseed <- isseed
}
class(out) <- "stdbscan"
clusterid <- as.matrix(out$cluster)
data <-cbind(data, clusterid)
return(clusterid)
}
stdbscan(data=data, eps=1, eps2=3)
stdbscan(data=data, eps=10, eps2=8)
stdbscan(data=data, eps=10, eps2=15)
stdbscan(data=data, eps=10, eps2=8)
stdbscan(data=data, eps=10, eps2=20)
stdbscan(data=data, eps=10, eps2=30)
c <-integer(p)
unc <- (1:p)[c < 0]
c <-integer(p)
unc <- (1:p)[c < 0]
c <-integer(p)
unc <- (1:p)[c < 1]
unc <- (1:p)[c < 8]
c <-integer(p)
unc <- (1:p)[c < 8]
help([])
countmode = 1:nrow(data)
n <- nrow(data_spasial)
rm(all)
rm
?rm
rm(list=ls())
setwd("C:/Users/eugeneby/Downloads")
options(scipen=999)
data <- read.csv("data.csv")
countmode = 1:nrow(data)
data_spasial<- dist(cbind(data$latitude,data$longitude))
n <- nrow(data_spasial)
data_spasial <- as.matrix(dist(cbind(data$latitude,data$longitude)))
n <- nrow(data_spasial)
cv <- integer(n)
for (i in 1:n) {
if (i %in% countmode)
unclass <- (1:n)[cv < 1]
}
for (i in 1:n) {
if (i %in% countmode)
unclass <- (1:n)[cv < 2]
}
for (i in 1:n) {
if (i %in% countmode)
unclass <- (1:n)[cv < 0]
}
for (i in 1:n) {
if (i %in% countmode)
unclass <- (1:n)[cv < 1]
}
cv
for (i in 1:n) {
if (i %in% countmode){
unclass <- (1:n)[cv < 1]
}
}
countmode
for (i in 1:n) {
if (i %in% countmode){
unclass <- (1:n)[cv < 5]
}
}
for (i in 1:n) {
if (i %in% countmode){
unclass <- (1:n)[cv(i) < 5]
}
}
for (i in 1:n) {
if (i %in% countmode){
unclass <- (1:n)[cv[i] < 5]
}
}
for (i in 1:n) {
if (i %in% countmode){
unclass <- (1:n)[n < 1]
}
}
for (i in 1:n) {
if (i %in% countmode){
unclass <- (1:n)[n < 8000]
}
}
for (i in 1:n) {
if (i %in% countmode){
unclass <- (1:n)[n < 4822]
}
}
for (i in 1:n) {
if (i %in% countmode){
unclass <- (1:n)[n < 4821]
}
}
for (i in 1:n) {
if (i %in% countmode){
unclass <- (1:n)[n <= 4821]
}
}
cv < 1
cv > 1
cv = 1
classn <- cv <- integer(n)
countmode = 1:nrow(data)
data_spasial <- as.matrix(dist(cbind(data$latitude,data$longitude)))
n <- nrow(data_spasial)
# Here, we are assigning the types of each output value.
# Both classn and cv will be integer vectors of size n.
cv <- integer(n)
cv
for (i in 1:n) {
if (i %in% countmode){
unclass <- (1:n)[countmode <= 4821]
}
}
for (i in 1:n) {
if (i %in% countmode){
unclass <- (1:n)[countmode <= 5]
}
}
?intersect
countmode = 1:nrow(data)
data_spasial <- as.matrix(dist(cbind(data$latitude,data$longitude)))
n <- nrow(data_spasial)
# Here, we are assigning the types of each output value.
# Both classn and cv will be integer vectors of size n.
cv <- integer(n)
cv
for (i in 1:n) {
if (i %in% countmode){
unclass <- (1:n)[cv < 1]
}
}
unclass[data_spasial[i, unclass]
temps <- unclass[data_spasial[i, unclass]]
temps <- unclass[data_spasial[i, unclass] < 10]
temps <- unclass[data_spasial[i, unclass] < 5]
data_spatial[i, unclass] < 5
data_spasial[i, unclass] < 5
unclass[data_spasial[i, unclass] < 5]
data_temporal <- as.matrix(dist(cbind(data$date)))
reachables <- intersect(unclass[data_spasial[i, unclass] <= eps],  unclass[data_temporal[i, unclass] <= eps2])
eps=10
eps2=15
reachables <- intersect(unclass[data_spasial[i, unclass] <= eps],  unclass[data_temporal[i, unclass] <= eps2])
reachables
eps=5
eps2=5
reachables <- intersect(unclass[data_spasial[i, unclass] <= eps],  unclass[data_temporal[i, unclass] <= eps2])
eps=5
eps2=5
reachables <- intersect(unclass[data_spasial[i, unclass] <= eps],  unclass[data_temporal[i, unclass] <= eps2])
reachables
eps=50
eps2=50
reachables <- intersect(unclass[data_spasial[i, unclass] <= eps],  unclass[data_temporal[i, unclass] <= eps2])
reachables
eps=50
eps2=500
reachables <- intersect(unclass[data_spasial[i, unclass] <= eps],  unclass[data_temporal[i, unclass] <= eps2])
reachables
#LOAD THE FOLLOWING PACKAGES THE FIRST TIME YOU USE R:
install.packages("sp")
install.packages("ISLR")
install.packages("MASS")
install.packages("spatstat")
install.packages("spatial")
install.packages("maptools")
install.packages("ppp")
install.packages("fossil")
install.packages("adehabitatHR")
install.packages("gdata")
install.packages("raster")
install.packages("rgdal")
install.packages("geostatsp")
library(graphics)
library(maptools)
library(spatstat)
library(sp)
library(fossil)
library(spatial)
library(adehabitatHR)
library(gdata)
library(raster)
library(rgdal)
library(geostatsp)
setwd("D:/Dropbox/Documents/Work and School/Teaching/CPLN 671 - Statistics and Data Mining/Point Pattern Analysis/Data/Quadrat Analysis Data")
#Reading Polygon Boundary.shp from the directory above
Boundary <- readShapePoly("Boundary.shp")
BoundaryPolygons <- as(Boundary, "SpatialPolygons")
BoundaryPolygonsOW<- as(BoundaryPolygons, "owin")
#Plotting the Boundary Window
plot(BoundaryPolygonsOW)
title(main = "Point Pattern Analysis")
Boundary <- rgdal::readOGR("Boundary.shp")
#Class "SpatialPolygons" holds polygon topology (without attributes)
BoundaryPolygons <- as(Boundary, "SpatialPolygons")
#The class "owin" is a way of specifying the observation window for a point pattern.
BoundaryPolygonsOW<- as(BoundaryPolygons, "owin")
#Plotting the Boundary Window
plot(BoundaryPolygonsOW)
title(main = "Point Pattern Analysis")
setwd("D:/Dropbox/Documents/Work and School/Teaching/CPLN 671 - Statistics and Data Mining/Homework Assignments/HW 4")
# nearest neighbor analysis
markets <- st_read("Philadelphia_Farmers_Markets201302.shp")
library(spatstat)
library(sf)
library(maptools)
setwd("D:/Dropbox/Documents/Work and School/Teaching/CPLN 671 - Statistics and Data Mining/Homework Assignments/HW 4")
markets <- st_read("Philadelphia_Farmers_Markets201302.shp")
View(markets)
View(markets)
Boundary <- readShapePoly("Philadelphia.shp")
BoundaryPolygons <- as(Boundary, "SpatialPolygons")
BoundaryPolygonsOW<- as(BoundaryPolygons, "owin")
markets.xy <- st_coordinates(markets)
pp <- ppp(markets.xy[,1], markets.xy[,2], window=BoundaryPolygonsOW)
# distance to nearest neighbor
nnd <- nndist.ppp(pp)
# observed average distance
MeanObsDist <- mean(nnd)
# expected average distance and SE
MeanExpDist <- 0.5 / sqrt(nrow(markets.xy) / area.owin(BoundaryPolygonsOW))
SE <- 0.26136 / sqrt(nrow(markets.xy)*nrow(markets.xy) / area.owin(BoundaryPolygonsOW))
View(markets.xy)
View(markets.xy)
setwd("D:/Dropbox/Documents/Work and School/Teaching/CPLN 671 - Statistics and Data Mining/Homework Assignments/HW 3")
mydata <- read.csv("Logistic Regression Data.csv")
head(mydata)
#install.packages("packagename")
install.packages("aod")
install.packages("ggplot2")
install.packages("rms")
install.packages("gmodels")
#install.packages("boot")
install.packages("DAAG")
install.packages("ROCR")
#library(packagename)
library(aod)
library(ggplot2)
library(rms)
library(gmodels)
library(boot)
library(DAAG)
library(ROCR)
#Logistic Regression
mylogit <- glm(DRINKING_D ~ FATAL_OR_M + OVERTURNED + CELL_PHONE + SPEEDING + AGGRESSIVE + DRIVER1617 + DRIVER65PLUS + PCTBACHMOR + MEDHHINC, data=mydata, family = "binomial")
summary(mylogit)
aic(mylogit)
summary(mylogit1)
mylogit1 <- glm(DRINKING_D ~ FATAL_OR_M + OVERTURNED + CELL_PHONE + SPEEDING + AGGRESSIVE + DRIVER1617 + DRIVER65PLUS, data=mydata, family = "binomial")
summary(mylogit1)
mylogit <- glm(DRINKING_D ~ FATAL_OR_M + OVERTURNED + CELL_PHONE + SPEEDING + AGGRESSIVE + DRIVER1617 + DRIVER65PLUS + PCTBACHMOR + MEDHHINC, data=mydata, family = "binomial")
summary(mylogit)
mylogit1 <- glm(DRINKING_D ~ FATAL_OR_M + OVERTURNED + CELL_PHONE + SPEEDING + AGGRESSIVE + DRIVER1617 + DRIVER65PLUS, data=mydata, family = "binomial")
summary(mylogit1)
