---
title: "MUSA 508 Final - Amsterdam"
author: 'Ben Keel, Yuhao Sun & Ann (Zian) Zhang'
date: "2022/12/06"
output: 
  html_document:
    theme: lumen
    toc: true
    toc_float: true
    toc_collapsed: true
    code_folding: hide
---

```{r setup, include=FALSE, message = FALSE,warning = FALSE, echo = FALSE}
knitr::opts_chunk$set(echo = TRUE, quiet = TRUE, warning=FALSE)
```
![Amsterdam's Canels, Wikipedia.](https://www.tripsavvy.com/thmb/WHLAB8cOtR6xLYohG0BwqmTfyLc=/1500x0/filters:no_upscale():max_bytes(150000):strip_icc()/GettyImages-552050827-5bd6e5bcc9e77c0026a2d26d.jpg)


# Presentation - Youtube Link

Please refer to our presentation video for executive summary of this project/app!

https://youtu.be/6dixtgleyY0


# Background Information -- Amsterdam Airbnb Market

Amsterdam as a world-class tourism city greets millions of tourists from all over the world. However, like many other European cities, it's so popular during the Summer that city officials want to [decrease their visitors](https://www.dutchnews.nl/news/2022/10/airbnb-style-rentals-harmful-to-amsterdam-says-tourism-chief/) to improve the experience for all tourists and residents. Those who live in Amsterdam permanently not only face frequent belligerently intoxicated tourists on 'moral holidays', but they also pay more for housing -- perhaps due to the short-term rental (STR) market propped up by the crush of visitors. [Regulations](https://www.euractiv.com/section/digital-single-market/news/eus-rulebook-on-short-term-rentals-puts-evidence-based-policymaking-to-the-test/) have been passed to limit the spread and availability of STR's like Airbnb through [local bans](https://www.reuters.com/article/us-netherlands-airbnb-amsterdam/amsterdam-to-allow-airbnb-rentals-in-city-centre-after-court-order-idUSKBN2B81NS) and annual day limits on full home rentals, but their execution upsets many landlords. Owners want more consistency between cities and less fragility in their investments, but the regulations will continue to change as policymakers reach a consensus.

Airbnb's are currently clustered in Amsterdam toward the historic centre of the city, but the market may shift. Crowd control and rental regulations closer to the center may result in more opportunities for those outside the central city to host B&B's, private rooms, or an STR during their vacation elsewhere. With a new host market and with more data coming in from local STR [registration requirements](https://www.airbnb.com/help/article/860), data professionals can create a better B&B set up process through tools like price prediction.

Like any business or landlord, Airbnb hosts are motivated to list their property by the potential profit. Price prediction serves new and current hosts by giving them a better estimation of their bottom line than the usual set up process. Airbnb itself gives general guidelines and offers a model of their own to dynamically adjust pricing, but it still requires a maximum and minimum. Other tools display benchmarks for hosts, but they have fewer listings to compare outside the cluster. As data professionals, we can do this better.

Model Host, the name we're giving our prediction tool, can serve these new people, especially ones outside the historic centre, with estimates of a current or potential property's rental value. Anticipating Amsterdam's mission to trade high-quantity tourism for high-quality experiences, our model here aims to grow responsible hosting opportunities, and promote a diversity of Airbnb locations in Amsterdam. When integrated into a user interface, residents could use price prediction to quickly see what opportunities are available to them. The following analysis aims to build this tool to benefit hosts and their visitors.

# Data Source

We acquired data from several reliable sources:

Airbnb Data (including price, location, amenities, room compositions, etc.) is acquired from Kaggle, a platform for sharing data set particularly for machine learning. This contains airbnb data in Amsterdam from 2017 December to 2018 December (hence, primarily data for the year of 2018). Although due to the pandemic, tourism in Amsterdam might have undergone changes and variation, this is the best possible data we have available, and we believe it would produce some insights. 
(https://www.kaggle.com/datasets/erikbruin/airbnb-amsterdam?select=listings.csv)

Neighborhood and surrounding amenities data is acquired from City of Amsterdam's online geo data portal, 'Maps Data.' (https://maps.amsterdam.nl/open_geodata/?LANG=en)

In addition, we supplemented data about tourist attrations from 'Tourpedia,' an online data portal with tourism-related data of several European cities. (http://tour-pedia.org/about/datasets.html)

```{r Load R packages, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}

source("https://raw.githubusercontent.com/urbanSpatial/Public-Policy-Analytics-Landing/master/functions.r")

library(tidyverse)
library(sf)
library(RSocrata)
library(viridis)
library(spatstat)
library(ggplot2)
library(raster)
library(spdep)
library(FNN)
library(mapview)
library(grid)
library(gridExtra)
library(knitr)
library(stringr)
library(kableExtra)
library(tidycensus)
library(lubridate)
library(viridis)
library(stargazer)
library(dplyr)
library(plyr)

library(scales)
library(RColorBrewer)
library(gridExtra)
library(ggthemes)
library(readr)
library(ggcorrplot)
library(caret)

library(sjPlot)
library(sjmisc)
library(sjlabelled)
library(osmdata)

#text mining
library(tm)
library(wordcloud2)
library(SnowballC)
options(scipen=999)
```

```{r formatting, include=FALSE, echo = TRUE, message = FALSE, warning = FALSE}

palette5 <- c("#FA8072","#9FE2BF","#FF006A","#FE4C35","#FE9900")
palette4 <- c("#FA8072","#9FE2BF","#FE4C35","#FE9900")
palette2 <- c("#FA8072","#9FE2BF")
Teal <- c("#d1eeea", "#a8dbd9", "#85c4c9", "#68abb8", "#4f90a6")
Purple <- c("#f3e0f7", "#e4c7f1", "#d1afe8", "#b998dd", "#9f82ce")
Pink <- c("#ffffff","#f9f4f4","#f0e4e4", "#e7d3d3", "#dec3c3")

qBr <- function(df, variable, rnd) {
  if (missing(rnd)) {
    as.character(quantile(round(df[[variable]],0),
                          c(.01,.2,.4,.6,.8), na.rm=T))
  } else if (rnd == FALSE | rnd == F) {
    as.character(formatC(quantile(df[[variable]]), digits = 3),
                 c(.01,.2,.4,.6,.8), na.rm=T)
  }
}

qBr2 <- function(df, variable, rnd) {
  if (missing(rnd)) {
    as.character(round(quantile(round(df[[variable]],0),
                          c(.01,.2,.4,.6,.8), na.rm=T)))
  } else if (rnd == FALSE | rnd == F) {
    as.character(round(formatC(quantile(round(df[[variable]]), 0)),
                 c(.01,.2,.4,.6,.8), na.rm=T))
  }
}

q5 <- function(variable) {as.factor(ntile(variable, 5))}

```

```{r function, include=FALSE, echo = TRUE, message = FALSE, warning = FALSE}
nn_function <- function(measureFrom,measureTo,k) {
  measureFrom_Matrix <- as.matrix(measureFrom)
  measureTo_Matrix <- as.matrix(measureTo)
  nn <-   
    get.knnx(measureTo, measureFrom, k)$nn.dist
  output <-
    as.data.frame(nn) %>%
    rownames_to_column(var = "thisPoint") %>%
    gather(points, point_distance, V1:ncol(.)) %>%
    arrange(as.numeric(thisPoint)) %>%
    group_by(thisPoint) %>%
    summarize(pointDistance = mean(point_distance)) %>%
    arrange(as.numeric(thisPoint)) %>% 
    dplyr::select(-thisPoint) %>%
    pull()
  
  return(output)  
}


rquery.wordcloud <- function(x, type=c("text", "url", "file"), 
                          lang="english", excludeWords=NULL, 
                          textStemming=FALSE,  colorPalette="Dark2",
                          min.freq=3, max.words=200)
{ 
  library("tm")
  library("SnowballC")
  library("wordcloud")
  library("RColorBrewer") 
  
  if(type[1]=="file") text <- readLines(x)
  else if(type[1]=="url") text <- html_to_text(x)
  else if(type[1]=="text") text <- x
  
  # Load the text as a corpus
  docs <- Corpus(VectorSource(text))
  # Convert the text to lower case
  docs <- tm_map(docs, content_transformer(tolower))
  # Remove numbers
  docs <- tm_map(docs, removeNumbers)
  # Remove stopwords for the language 
  docs <- tm_map(docs, removeWords, stopwords(lang))
  # Remove punctuations
  docs <- tm_map(docs, removePunctuation)
  # Eliminate extra white spaces
  docs <- tm_map(docs, stripWhitespace)
  # Remove your own stopwords
  if(!is.null(excludeWords)) 
    docs <- tm_map(docs, removeWords, excludeWords) 
  # Text stemming
  if(textStemming) docs <- tm_map(docs, stemDocument)
  # Create term-document matrix
  tdm <- TermDocumentMatrix(docs)
  m <- as.matrix(tdm)
  v <- sort(rowSums(m),decreasing=TRUE)
  d <- data.frame(word = names(v),freq=v)
  # check the color palette name 
  if(!colorPalette %in% rownames(brewer.pal.info)) colors = colorPalette
  else colors = brewer.pal(8, colorPalette) 
  # Plot the word cloud
  set.seed(1234)
  wordcloud(d$word,d$freq, min.freq=min.freq, max.words=max.words,
            random.order=FALSE, rot.per=0.35, 
            use.r.layout=FALSE, colors=colors)
  
  invisible(list(tdm=tdm, freqTable = d))
}
#++++++++++++++++++++++
# Helper function
#++++++++++++++++++++++
# Download and parse webpage
html_to_text<-function(url){
  library(RCurl)
  library(XML)
  # download html
  html.doc <- getURL(url)  
  #convert to plain text
  doc = htmlParse(html.doc, asText=TRUE)
 # "//text()" returns all text outside of HTML tags.
 # We also donâ€™t want text such as style and script codes
  text <- xpathSApply(doc, "//text()[not(ancestor::script)][not(ancestor::style)][not(ancestor::noscript)][not(ancestor::form)]", xmlValue)
  # Format text vector into one character string
  return(paste(text, collapse = " "))
}
```

```{r load data, include=FALSE, echo = TRUE, message = FALSE, warning = FALSE}

#listings <- st_read("listings.csv")
#details <- st_read("listings_details.csv")
#calendar <- read.csv("calendar.csv")


details <- read.csv("/Users/annzhang/Downloads/archive/listings_details.csv")
listings <- read.csv("/Users/annzhang/Downloads/archive/listings.csv")
calendar <- read.csv("/Users/annzhang/Downloads/archive/calendar.csv")


#large neighborhood
neighborhood <- st_read('neighbourhoods.geojson')

#small neighborhood
neighbor2 <- st_read('neighbor2.json') %>% 
  st_transform(st_crs(neighborhood))

developing_area <- st_read('developing_area.json') %>% 
  st_transform(st_crs(neighborhood))

crowdsensor <- st_read('crowdsensor.json') %>% 
  st_transform(st_crs(neighborhood))

metro <- st_read('tram_metro_stops.json') %>% 
  st_transform(st_crs(neighborhood))

buildingyear <- st_read('buildingyearblock.json') %>% 
  st_transform(st_crs(neighborhood))

zipcode6 <- st_read('zipcode6.json') %>% 
  st_transform(st_crs(neighborhood))

zipcode4 <- st_read('zipcode4.json') %>% 
  st_transform(st_crs(neighborhood))
```

```{r  text, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}
details.sf <- st_as_sf(details,coords = c('longitude','latitude'),crs = 4326) %>% 
  st_transform(st_crs(neighborhood))

details.sf$price <- parse_number(details.sf$price)
details.sf$weekly_price <- parse_number(details.sf$weekly_price)
details.sf$monthly_price <- parse_number(details.sf$monthly_price)
details.sf$cleaning_fee <- parse_number(details.sf$cleaning_fee)
details.sf$extra_people <- parse_number(details.sf$extra_people)
details.sf$security_deposit <- parse_number(details.sf$security_deposit)
details.sf$beds <- as.numeric(details.sf$beds)
details.sf$minimum_nights <- as.numeric(details.sf$minimum_nights)
details.sf$maximum_nights <- as.numeric(details.sf$maximum_nights)
details.sf$number_of_reviews <- as.numeric(details.sf$number_of_reviews)
details.sf$review_scores_rating <- as.numeric(details.sf$review_scores_rating)
details.sf$review_scores_accuracy <- as.numeric(details.sf$review_scores_accuracy)
details.sf$review_scores_cleanliness<- as.numeric(details.sf$review_scores_cleanliness)
details.sf$review_scores_value <- as.numeric(details.sf$review_scores_value)
details.sf$reviews_per_month <- as.numeric(details.sf$reviews_per_month)
details.sf$id <- as.character(details.sf$id)
details.sf$property_type <- as.factor(details.sf$property_type)

details.sf.raw <- details.sf
```

# Exploratory Analysis

Since the Airbnb data already contains a lot of information (hiding many secrets!), we will first conduct exploratory analysis by examining location (geographic distribution) of available units, price per night, occupancy, room characteristics (composition, layout), and amenities that come with the room. Looking into those aspects can help our clients, future Airbnb host, to quickly identify internal characteristics of their unit and set price. It may also help those hosts who wish to upgrade their units figure out a potential increase in price after the upgrade. 

```{r price panel, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}
# Available Calendar
available_calendar <- calendar %>%
  filter(available =="t")

available_calendar$listing_id <- as.character(available_calendar$listing_id)

# Price change
available_calendar <- available_calendar%>%
  mutate(price2 = gsub("^.","",price))%>%
  mutate(price2 = gsub(",","",price2))

available_calendar$price3 <- as.numeric(available_calendar$price2)

# Sum per month
available_calendar2 <- available_calendar%>%
  mutate(date2 = ymd(date))%>%
  mutate(month = month(date2))%>%
  group_by(listing_id, month) %>%
  dplyr::summarize(month_price = mean(price3))
```

```{r panel length, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}
length(unique(calendar$listing_id))
length(unique(calendar$listing_id))*12
```

```{r deal with panel, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}
study.panel <- 
  expand.grid(listing_id = unique(calendar$listing_id),
              month=unique(available_calendar2$month))
study.panel$listing_id <- as.character(study.panel$listing_id)
listing_panel <- study.panel %>%
  left_join(available_calendar2) %>%
  mutate(each_month_price = 0)
o <- order(listing_panel[,"listing_id"],listing_panel[,"month"])
listing_panel <- listing_panel[o,]
xx <- 0
for(i in 2:nrow(listing_panel)){
  if(!is.na(listing_panel[i,3])){
    xx <- listing_panel[i,3]
    listing_panel[i,4]=listing_panel[i,3]
  }
  if(is.na(listing_panel[i,3])& listing_panel[i-1,1]==listing_panel[i,1]){
    listing_panel[i,4] <- xx
  }
  if(is.na(listing_panel[i,3])& listing_panel[i-1,1]!=listing_panel[i,1]){
    xx <- 0
    listing_panel[i,4] <- xx
  }
}
d <- order(listing_panel[,"listing_id"],-listing_panel[,"month"])
listing_panel <- listing_panel[d,]
for(i in 2:nrow(listing_panel)){
  if(listing_panel[i,4]==0){
    listing_panel[i,4]=listing_panel[i-1,4]
  }
}
o <- order(listing_panel[,"listing_id"],listing_panel[,"month"])
listing_panel <- listing_panel[o,]
listing_0price <- listing_panel %>%
  filter(each_month_price == 0)
no_price <- unique(listing_0price$listing_id)

```

```{r drop NA listings, include=FALSE, echo = TRUE, message = FALSE, warning = FALSE}
#Filter data with no price
listing_panel <- listing_panel %>%
  filter(!listing_id %in% no_price)
```

## 1) Geographic Distribution

Firstly, identifying 'hotspots' would be helpful to have an overview of the Airbnb market in Amsterdam. On the one hand, the existing units are usually located in areas where tourists would want to stay, which equates to decent demand. On the other hand, adequate supply means there may be a competition in the market. 

Given city government's concern with too many Airbnb (short-term rental) concentrating in central historic areas, the maps below also help demonstrating how the market indeed is crammed in the central area. 

We choose to examine the distribution at two scales -- neighborhood (identified by City of Amsterdam) and zip code areas (smaller scale). Both maps show that many Airbnb are located along the canals, which is usually deemed signature of Amsterdam. 

```{r }
mapTheme <- theme(plot.title =element_text(size=12),
                  plot.subtitle = element_text(size=8),
                  plot.caption = element_text(size = 8),
                  axis.line=element_blank(),
                  axis.text.x=element_blank(),
                  axis.text.y=element_blank(),
                  axis.ticks=element_blank(),
                  axis.title.x=element_blank(),
                  axis.title.y=element_blank(),
                  panel.background=element_blank(),
                  panel.border = element_rect(colour = "black", fill=NA, size=2),
                  panel.grid.major=element_line(colour = 'grey92'),
                  panel.grid.minor=element_blank(),
                  legend.direction = "vertical", 
                  legend.position = "right",
                  plot.margin = margin(1, 1, 1, 1, 'cm'),
                  legend.key.height = unit(1, "cm"), legend.key.width = unit(0.2, "cm"))
```


```{r plot the number of airbnb, fig.width=6.4, fig.height=6.0, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}
sf_use_s2(FALSE)
listings.sf<- listings %>% 
  st_as_sf(coords = c( "longitude","latitude"), crs = 4326, agr = "constant") %>% st_transform('ESRI:102013')

neighbor2 <- neighbor2 %>% 
  st_transform(st_crs(listings.sf))

listing.sf.neighbor2 <- st_intersection(listings.sf,neighbor2) %>% 
  dplyr::select(id, Buurt,Buurt_code) %>% 
  mutate(count=1) %>% 
  st_drop_geometry()

listings.sf <- left_join(listings.sf, listing.sf.neighbor2,by='id')

neighbo2.count <- listings.sf %>% 
  group_by(Buurt) %>%
  dplyr::summarise(airbnb.number = sum(count)) %>% 
  dplyr::select(Buurt, airbnb.number) %>% 
  st_drop_geometry()

neighbor2 <- left_join(neighbor2,neighbo2.count,by="Buurt")

ggplot()+
  geom_sf(data = neighbor2, aes(fill=q5(airbnb.number)),color='transparent')+
  scale_fill_manual(values = Teal,
                     labels = qBr(neighbor2,'airbnb.number'), name = 'Count')+
  labs(title = "Number of Airbnb per Neighborhood", subtitle = "Amsterdam, NL; 2018") +
  mapTheme()
```

```{r  fig.width=6.4, fig.height=6.0, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}


neighbor2 %>% ggplot() + 
      geom_sf(aes(fill = airbnb.number), color = 'white') +
      scale_fill_gradient(low = Teal[1], high = Teal[5],
                          name = "Count") +
      labs(title = "Number of Airbnb per Zipcode", subtitle = "Amsterdam, NL; 2018") +
      mapTheme()
```


## 2) Price

### Seasonality

The plot below shows the relationship between seasonality and price -- we see an annual low in the beginning of the year in Jan and Feb, and a quick incline as spring comes, hitting high points in the summer, than slowly declines as weather gets colder into fall and winter. The price seems to follow the general trend of tourism in Amsterdam. 

```{r price change, fig.width=8, fig.height=3.8, include = TRUE, echo=TRUE, warning= FALSE, message=FALSE}
Month_price <- calendar%>%
  mutate(date2 = ymd(date))%>%
  mutate(month = month(date2),
         listing_id = as.character(listing_id),
         price = parse_number(price))%>%
  mutate(month = as.character(month))%>%
  mutate(month = ifelse(month != 10 & month != 11 & month != 12, gsub("^","0",month), month)) %>%
  drop_na(price) %>%
  group_by(month) %>%
  dplyr::summarize(mean_monthly_price = mean(price))


ggplot(Month_price, 
       aes(x=month, y=mean_monthly_price, group =1)) +
  geom_line(size=1, color = Teal[3]) +
  labs(title = "Average Airbnb Price Every Month", subtitle = "Amsterdam, NL; 2018") +
  xlab("Month of the Year") + ylab("Average Price") +
  plotTheme()
```

### Price per Bed

Since each Airbnb varies in size and number of guests it can accommodate, we choose to visualize price per bed to make a better sense of the price in the market. A bed usually can accommodate 2 guests maximum, though in some case can host up to 3 guests. Again, the higher priced bed are concentrated in the central areas.

```{r plot price per bed, fig.width=6.4, fig.height=6.0, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}
details.sf <- 
  details.sf %>% 
  mutate(priceBed=price/beds) %>% 
  filter(priceBed <=1000)


ggplot()+
  geom_sf(data = neighborhood,fill='grey95',color = 'white')+
  geom_sf(data = details.sf, aes(colour=q5(priceBed)),size=.5)+
  scale_color_manual(values = palette5,
                     labels = qBr(details.sf,'priceBed'), name="Price per Bed (Euro)") +
  labs(title = "Price per Bed",
       subtitle = 'Amsterdam Airbnb, price on 2018-12-6') +
  mapTheme()

```

## 3) Occupancy

While location and price are helpful information, we shall not disregard an important indicator of actual profit -- occupancy. From the existing data, we can see that occupancy is lower in the beginning of the year, then continues to be high year-round. However, it is important to acknowledge the fact that Feburary only has 28 (or 29) days, which may result in lower occupancy count. 


```{r occupancy, fig.width=8, fig.height=3.8, include = TRUE, echo=TRUE, warning=FALSE, message=FALSE}
index <- function(x, flag = '0') {
  digit <- floor(log10(length(x))) + 1
  paste(flag, formatC(x, width = digit, flag = '0'), sep = '')
}

occupancy <- calendar%>%
  mutate(date2 = ymd(date))%>%
  mutate(month = month(date2),
         count = ifelse(available == "f", 1, 0),
         listing_id = as.character(listing_id))%>%
  filter(!listing_id %in% no_price) %>%
  group_by(listing_id, month) %>%
  dplyr::summarize(monthly_occupancy = sum(count))

monthly_occupancy <- occupancy %>%
  mutate(month = as.character(month))%>%
  mutate(month = ifelse(month != 10 & month != 11 & month != 12, gsub("^","0",month), month)) %>%
  group_by(month) %>%
  dplyr::summarise(mean_monthly_occupancy = mean(monthly_occupancy))

ggplot(monthly_occupancy, 
       aes(x=month, y=mean_monthly_occupancy, group =1)) +
  geom_line(size=1, color = "#FE9900") +
  labs(title = "Airbnb Occupancy Every Month", subtitle = "Amsterdam, NL; 2018") +
  xlab("Month of the Year") + ylab("Average Monthly Occupancy") +
  plotTheme()
```

## 4) Composition / Characteristics

Move on to internal features of the units -- number of beds, bedrooms, bathrooms, and number of guests it may accommodate -- are all fundamentals for determining a unit's price (and directly associated with guests; willingness to pay). In addition, since Amsterdam has a long history of having boat house and all kinds of special types of houses, tourists may be in favor of experiencing those kinda of accommodation. Hence, we did a thorough examination of all those features and their aggregated effect. 

### Room Layout

```{r basic features, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}

table.basic <- details.sf %>% 
  st_drop_geometry() %>% 
  dplyr::select(price ,beds, bedrooms, bathrooms, accommodates)

stargazer(as.data.frame(table.basic),
          type = "text",
          title ="Table 1. Basic Features Summary",
          single.row = TRUE,
          out.header = TRUE)

```

### Property Type

```{r}
count(details.sf$property_type) %>%
  kable() %>%
  kable_styling() %>%
  scroll_box(width = "800px", height = "200px")

```

### Puting them together...

After examining individual internal features, we put together the table below to show average price for each combination of all those features. We can see that even with the same number of beds, bathrooms, bedrooms, and no. of accommodating guests, property_type may be a determinant for price. 

We have decided to include all those internal features into our machine learning model since they appear to be valid factors. 

```{r include=TRUE}

details.sf %>%
  st_drop_geometry() %>%
  group_by(beds, bathrooms, bedrooms, accommodates, property_type) %>%
  dplyr::summarize(Mean_Price = mean(price)) %>%
  kable() %>%
  kable_styling() %>%
  scroll_box(width = "800px", height = "200px")

```

## 5) Amenities

Rooms amenities are also important. Whether your unit comes with a pool, parking space, fireplace, kitchen, or close to waterfront could largely change tourists' staying experience. Hence, we look at all the individual amenities and their effect on price. 

```{r amenities, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}
#pool
details.sf <- details.sf %>%
  mutate(pool = ifelse(str_detect(amenities, "Pool"), "Yes", "No"))

#Paid parking off premises
details.sf <- details.sf %>%
  mutate(parking = ifelse(str_detect(amenities, "Paid parking off premises"), 
                          "Yes", "No"))

#Indoor fireplace
details.sf <- details.sf %>%
  mutate(fireplace = ifelse(str_detect(amenities, "Indoor fireplace"), 
                          "Yes", "No"))

#Waterfront
details.sf <- details.sf %>%
  mutate(waterfront = ifelse(str_detect(amenities, "Waterfront"), 
                          "Yes", "No"))

#Kitchen
details.sf <- details.sf %>%
  mutate(kitchen = ifelse(str_detect(amenities, "Kitchen"), 
                          "Yes", "No"))

#Air conditioning
details.sf <- details.sf %>%
  mutate(AC = ifelse(str_detect(amenities, "Air conditioning"), 
                          "Yes", "No"))
```

```{r plot amenities,fig.width=10, fig.height=6.8, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}
amenitie_vars <- c('fireplace','waterfront','pool','parking','kitchen','AC')
plotList <- list()

for (i in amenitie_vars){
plotList[[i]] <- 
  details.sf %>%st_drop_geometry() %>% 
  dplyr::select(price,i) %>%
  filter(price<500) %>% 
  gather(Variable, value, -price) %>%
    ggplot(aes(value, price, fill=value)) + 
      geom_boxplot() +
      scale_fill_manual(values = c("#FFDD94", "#CCABDB")) +
      labs(x="Amenity Status", y="Price",
           title = i) +
      theme(legend.position = "none") +
  plotTheme()
}

do.call(grid.arrange,c(plotList, ncol = 3, top = "Price w/ vs. w/o Amenities"))
```

From the box plot above, we can tell that fireplace, waterfront, pool, and kitchen seem to have a decent influence on price, while parking and AC have subtle effect. Since Amsterdam is usually cool in the summer and chilly in winter, it makes sense why AC maybe less appealing than fireplace. We 


### Aggregated Amenities:

In addition to each amenities listed above, we also included a feature named 'amenities.number' to explore the aggregated effect of amenities. Sometimes, regardless of specific types of amenities, simply the fact of having multiple amenities may increase the price visitors are willing to pay for an Airbnb.

```{r number of amenties listed, include=FALSE, echo = TRUE, message = FALSE, warning = FALSE}
library(stringr)

details.sf <- details.sf %>% 
  mutate(amenities.number = str_count(amenities,",")+1)

```

# New Features & Engineering

In addition to internal features that we examined earlier, we also want to take some external factors that are critical for tourists into considerations -- the neighborhood (area), distance to public transit stops, and distance to some tourists attractions (e.g. museums) and external amenities (supermarkets and convenience shops). As tourists can benefit a lot from close proximity to sites they want to visit or amenities, the price may go up for those units that are closer to those places. 


## New Feature 1: Spatial Lag & Neighborhood Effect

There is a subtle difference between neighborhood effect -- spatial lag takes the price / revenue of surrounding areas and use the spatial lag revenue as a factor for pricing; neighborhood effect considers the spatial aspects and use neighborhood as a factor, since the location of a unit may silently speak for many other factors that may impact the price. Here we are considering both. 

### Neighborhood Effect

To account for neighborhood effect, we used the smaller scale 481 neighborhood system instead of the larger districts to increase precision. 

```{r Neighborhood Effect, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE }
details.sf.neighbor <- st_intersection(details.sf,zipcode4) %>% 
  dplyr::select(id, Postcode4) %>% 
  st_drop_geometry()

details.sf <- left_join(details.sf,details.sf.neighbor,by='id')

```

```{r neighbor effect2 , include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}
neighbor2 <- neighbor2 %>% 
  st_transform(st_crs(listings.sf))

listing.sf.neighbor2 <- st_intersection(listings.sf,neighbor2) %>% 
  dplyr::select(id, Buurt,Buurt_code) %>% 
  mutate(count=1) %>% st_drop_geometry()

listing.sf.neighbor2$id <- as.character(listing.sf.neighbor2$id)

detail.sf <- left_join(details.sf,listing.sf.neighbor2, by = "id")
```

### Spatial Lag

To calculate spatial lag, we used revenue instead of price because while price may be a subjective decision by the host, revenue speaks more about the market and how this area is doing in terms of profitability. Whether or not a host is likely to profit may impact their business decisions. 

```{r occupancy join, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}
occupancy3 <- occupancy %>%
  dplyr::rename(id = listing_id) 
  
occupancy3 <-  
  left_join(occupancy3, st_drop_geometry(details.sf), by = "id")
```

```{r price by month, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}
listing_panel <- listing_panel%>%
   dplyr::rename(id = listing_id)

revenue_panel <- merge(occupancy3,listing_panel[c("id","month","each_month_price")],by=c("id","month")) %>%
  mutate(revenue = each_month_price*monthly_occupancy)
```

```{r correlation matrix, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}

annualrevenue <- revenue_panel %>%
  group_by(id) %>%
  dplyr::summarise(annual_revenue = sum(revenue))


annualrevenue<- left_join(details.sf, annualrevenue,by="id")%>%
    filter(!id %in% no_price)%>%
    mutate(bathrooms = as.numeric(bathrooms),
         bedrooms = as.numeric(bedrooms))
```

```{r annual revenue spatial lag, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}

annualrevenue<- annualrevenue %>%
  drop_na(annual_revenue) %>%
  filter(annual_revenue <= 500000)

coords <- st_coordinates(annualrevenue) 

neighborList <- knn2nb(knearneigh(coords, 5))

spatialWeights <- nb2listw(neighborList, style="W")


annualrevenue$lagRevenue <- lag.listw(spatialWeights, annualrevenue$annual_revenue)

```

```{r annual revenue & spatial lag plot, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}
ggplot(annualrevenue)+
  geom_point(aes(x = price, y = annual_revenue), alpha = 0.26)+
  geom_smooth(aes(x = price, y =annual_revenue), method = "lm", se= FALSE, color = "orange")+
  labs(title="Price as a function of lagRevenue", y='Price', x = 'Lag Annual Revenue') +
  plotTheme()
```

The graph above shows price as function of lag annual revenue. We can recognize a clear positive correlation from this graph -- the more money neighboring Airbnb makes, the higher an Airbnb is tend to price since they may have the confidence of having sufficient demand. We therefore also included lagRevenue into our model. 

## New Feature 2: Access to Public Transit

The second set of features is the proximity to public transit. We first plotted the existing metro and tram stations in the city. We can see a pretty clear pattern of higher density of Aibnb near stations. But, does it matter when it comes to pricing?

This also hints that if the government are to generate new policies for encouraging development in other areas, including directing more Airbnb hosts to rent out units in peripheral areas, they may need to solve the public transit accessibility issue first.

```{r}
listings$longitude = as.numeric(listings$longitude)
listings$latitude = as.numeric(listings$latitude)
listings.sf<- listings %>% 
  st_as_sf(coords = c( "longitude","latitude"), crs = 4326, agr = "constant")

st_crs(metro) <- st_crs(listings.sf)

st_c <- st_coordinates

details.sf.c <- details.sf %>%
  st_transform('ESRI:102013') 

metro.c <- metro%>%
  st_transform('ESRI:102013') 


```

```{r}
ggplot()+
  geom_sf(data = neighbor2, aes(fill=q5(airbnb.number)),color='transparent') +
  scale_fill_manual(values = Pink,
                     labels = qBr(neighbor2,'airbnb.number'), name = 'Count of Airbnb') +
  geom_sf(data=metro.c$geometry, aes(color=metro.c$Modaliteit)) +
  scale_color_manual(values=c(palette2[1], '#7171C6'), name = 'Type of Transit') +
  labs(title = "Public Transit & Number of Airbnb", subtitle = "Amsterdam, NL; 2018") +
  mapTheme()
```

```{r Metro Buffer}

#multi-ring buffer 
Metro_MRB <- multipleRingBuffer(st_union(metro.c), 6500, 500)

#USE FOR REG: MRB Spatial Join 
details.sf.c.MetroRings <-
  st_join(dplyr::select(details.sf.c, id),
          Metro_MRB) %>%
  st_drop_geometry() %>% 
  left_join(details.sf.c, annualrevenue,
            by="id") %>%
  st_sf()%>%
  mutate(metro.dist = distance/1000)

#Adding the variable to the data set
details.sf <- 
  left_join(details.sf, details.sf.c.MetroRings %>% st_drop_geometry() %>% dplyr::select(metro.dist, id), by="id") %>%
  dplyr::rename(metro.dist = distance)
  
#FOR VIS ONLY: Creating a summary table of the ring data 
details.Rings.Summary <- details.sf.c.MetroRings %>%
  dplyr::select(metro.dist, price)%>%
  st_drop_geometry()%>%
  group_by(metro.dist)%>%
  dplyr::summarize(Price=median(price, na.rm=T))

#FOR VIS ONLY: Line Plot of the summary table 
ggplot(data=details.Rings.Summary, aes(x=metro.dist, y=Price),)+
  geom_line(size=1.5)+
  geom_point(size = 3)+  
  labs(title = "Price as a Function of Distance from a Metro Station", 
       subtitle = "Amsterdam Airbnb Data, 2018", 
       x="Distance from a Metro Station (KM)",
       y="Price (2018 Euro)")+
  theme(plot.title = element_text(size=18))
```

The plot above shows an interesting pattern of the relationship between price and distance from metro station. we can see a declining trend from the closest to station to around 4.5 km, then a striking increase in price. This could be due to the fact that after 4.5 it falls into the close proximity to another station, hence the price is risen again. The dramatic ups and downs also signals that it might be a valid factor for pricing. 


```{r}

annualrevenue <-
  annualrevenue %>%
  left_join(details.sf.c.MetroRings %>% st_drop_geometry %>% dplyr::select(metro.dist, id), by = 'id')

```



## New Feature 3: Proximity to Tourist Amenities

The third set of features we look at are tourist amenities, including UNESCO sites, parks, tourist attractions, museums, malls, convenience shops, plazas, and supermarkets. They are either possible incentives for tourists or just amenities for convenience / daily shopping. Given the fact that Airbnb is unlike hotel where all kinds of services are provided, tourists staying at Airbnb may be visiting shopping facilities more frequently to do last-minute shopping. 

```{r outside attractions,  include=TRUE, echo = TRUE, message = FALSE, warning = FALSE, results='hide'}
unesco <-
  #st_read('UnescoWerelderfgoed_region.shp') %>%
  st_read('geojson_lnglat.json') %>%
  st_transform('ESRI:102013')

parks <- st_read('parks.json') %>% 
  st_transform('ESRI:102013')

attraction <- st_read('amsterdam-attraction.csv') %>% 
  filter(lat != 'attraction')
attraction <- st_as_sf(attraction,coords = c('lng','lat'),crs = 4326) %>% 
  st_transform('ESRI:102013')

parks <- attraction %>% 
  filter(subCategory == 'Park')

museum <- attraction %>% 
  filter(subCategory == 'Museum')

```

```{r outside amenities , include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}

#supermarkets
supermarkets <- getbb('Amsterdam') %>% 
  opq() %>% 
  add_osm_feature('shop','supermarket') %>% 
  osmdata_sf() 
supermarkets <- supermarkets$osm_points %>% 
  dplyr::select(geometry)%>% 
  st_transform('ESRI:102013')%>% 
  dplyr::select(geometry) %>% 
  mutate(Legend = "supermarkets")

convenienceshop <- getbb('Amsterdam') %>% 
  opq() %>% 
  add_osm_feature('shop','convenience') %>% 
  osmdata_sf() 
convenienceshop <- convenienceshop$osm_points %>% 
  dplyr::select(geometry)%>% 
  st_transform('ESRI:102013')%>% 
  dplyr::select(geometry) %>% 
  mutate(Legend = "convenienceshop")

mall <- getbb('Amsterdam') %>% 
  opq() %>% 
  add_osm_feature('shop','mall') %>% 
  osmdata_sf() 
mall<- mall$osm_points %>% 
  dplyr::select(geometry)%>% 
  st_transform('ESRI:102013') %>% 
  dplyr::select(geometry) %>% 
  mutate(Legend = "mall")


attraction <- st_as_sf(attraction,coords = c('lng','lat'),crs = 4326) %>% 
  st_transform('ESRI:102013')


plaza <- attraction %>% 
  filter(subCategory == 'Plaza') 


beach <- attraction %>% 
  filter(subCategory == 'Beach') 


nightclub <- attraction %>% 
  filter(subCategory == 'Nightclub') 

```

```{r calculate distance to amenities & attractions , include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}

dist <- 1000

details.sf.c.attractions <- details.sf %>%
  dplyr::select(id)

#malls
mallBuffer <- st_union(st_buffer(mall, dist))%>%
    st_sf()

details.sf.c.attractions <- 
  rbind(
    details.sf.c[mallBuffer,] %>%
      st_drop_geometry() %>%
      left_join(details.sf.c.attractions) %>%
      st_sf() %>%
      mutate(mall.close = "y"),
    details.sf.c[mallBuffer, op = st_disjoint] %>%
      st_drop_geometry() %>%
      left_join(details.sf.c.attractions) %>%
      st_sf() %>%
      mutate(mall.close = "n"))
  
#supermarkets
supermarketsBuffer <- st_union(st_buffer(supermarkets, dist))%>%
    st_sf()

details.sf.c.attractions <- 
  rbind(
    details.sf.c[supermarketsBuffer,] %>%
      st_drop_geometry() %>%
      left_join(details.sf.c.attractions) %>%
      st_sf() %>%
      mutate(supermarkets.close = "y"),
    details.sf.c[supermarketsBuffer, op = st_disjoint] %>%
      st_drop_geometry() %>%
      left_join(details.sf.c.attractions) %>%
      st_sf() %>%
      mutate(supermarkets.close = "n"))

#dist.convenienceshop

details.sf.c.attractions <- 
  rbind(
    details.sf.c[st_union(st_buffer(convenienceshop, dist)),] %>%
      st_drop_geometry() %>%
      left_join(details.sf.c.attractions) %>%
      st_sf() %>%
      mutate(convenienceshop.close = "y"),
    details.sf.c[st_union(st_buffer(convenienceshop, dist)), op = st_disjoint] %>%
      st_drop_geometry() %>%
      left_join(details.sf.c.attractions) %>%
      st_sf() %>%
      mutate(convenienceshop.close = "n"))

#dist.museum
details.sf.c.attractions <- 
  rbind(
    details.sf.c[st_union(st_buffer(museum, dist)),] %>%
      st_drop_geometry() %>%
      left_join(details.sf.c.attractions) %>%
      st_sf() %>%
      mutate(museum.close = "y"),
    details.sf.c[st_union(st_buffer(museum, dist)), op = st_disjoint] %>%
      st_drop_geometry() %>%
      left_join(details.sf.c.attractions) %>%
      st_sf() %>%
      mutate(museum.close = "n"))

#dist.plaza
details.sf.c.attractions <- 
  rbind(
    details.sf.c[st_union(st_buffer(plaza, dist)),] %>%
      st_drop_geometry() %>%
      left_join(details.sf.c.attractions) %>%
      st_sf() %>%
      mutate(plaza.close = "y"),
    details.sf.c[st_union(st_buffer(plaza, dist)), op = st_disjoint] %>%
      st_drop_geometry() %>%
      left_join(details.sf.c.attractions) %>%
      st_sf() %>%
      mutate(plaza.close = "n"))

#dist.nightclub
details.sf.c.attractions <- 
  rbind(
    details.sf.c[st_union(st_buffer(nightclub, dist)),] %>%
      st_drop_geometry() %>%
      left_join(details.sf.c.attractions) %>%
      st_sf() %>%
      mutate(nightclub.close = "y"),
    details.sf.c[st_union(st_buffer(nightclub, dist)), op = st_disjoint] %>%
      st_drop_geometry() %>%
      left_join(details.sf.c.attractions) %>%
      st_sf() %>%
      mutate(nightclub.close = "n"))

#dist.beach
details.sf.c.attractions <- 
  rbind(
    details.sf.c[st_union(st_buffer(beach, dist)),] %>%
      st_drop_geometry() %>%
      left_join(details.sf.c.attractions) %>%
      st_sf() %>%
      mutate(beach.close = "y"),
    details.sf.c[st_union(st_buffer(beach, dist)), op = st_disjoint] %>%
      st_drop_geometry() %>%
      left_join(details.sf.c.attractions) %>%
      st_sf() %>%
      mutate(beach.close = "n"))

#dist.parks
details.sf.c.attractions <- 
  rbind(
    details.sf.c[st_union(st_buffer(parks, dist)),] %>%
      st_drop_geometry() %>%
      left_join(details.sf.c.attractions) %>%
      st_sf() %>%
      mutate(parks.close = "y"),
    details.sf.c[st_union(st_buffer(parks, dist)), op = st_disjoint] %>%
      st_drop_geometry() %>%
      left_join(details.sf.c.attractions) %>%
      st_sf() %>%
      mutate(parks.close = "n"))

details.sf.attractions <-
  left_join(details.sf, st_drop_geometry(details.sf.c.attractions), by="id")

```

```{r}
table.distance <- details.sf.attractions %>% 
  st_drop_geometry() %>% 
  dplyr::select(price.y, museum.close,plaza.close,nightclub.close,beach.close,
                  supermarkets.close, parks.close, mall.close, convenienceshop.close)

table.distance %>%
  gather(Variable, value, -price.y) %>%
    ggplot(aes(value, price.y, fill=value)) + 
      geom_bar(position = "dodge", stat = "summary", fun = "mean") + 
      facet_wrap(~Variable, scales = "free") +
      scale_fill_manual(values = palette2) +
      labs(x="Within 1KM?", y="Average Price", 
           title = "Feature Associations with Proximity to Attractions",
           subtitle = "Amsterdam Airbnbs, 2018") +
      theme(legend.position = "none")
```

Similar to internal amenities, we drew box plots for external amenities. We compared price of Airbnb that has particular amenities within the 1km walkable distance, versus without those amenities in close proximity. We can see that apart from beach, nightclubs, and parks, all five other factors seem to make a difference when it comes to determining Airbnb price. 


```{r}


annualrevenue <-
  annualrevenue %>%
  left_join(details.sf.c.attractions %>% st_drop_geometry %>% dplyr::select(id, convenienceshop.close, mall.close, museum.close, plaza.close, supermarkets.close), by = 'id')

```



# Feature Review: Correlation Matrix

The correlation matrix below is a quick check-up on whether our factors are correlated to each other. If they are, we will choose one to include in model and the other(s) to disregard. Apart from beds and bedrooms, all other factors seem to be fine to be included in the model simultaneously. 

```{r numeric correlation matrix, fig.width=6.4, fig.height=6.0, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}
numericVars <- 
  select_if(st_drop_geometry(annualrevenue), is.numeric) %>% na.omit() %>% 
  dplyr::select(annual_revenue,price,beds, bedrooms, bathrooms, 
                              minimum_nights,
                              amenities.number, metro.dist)

ggcorrplot(
  round(cor(numericVars), 1), 
  p.mat = cor_pmat(numericVars),
  colors = c("#4757a2", "white", "#E46B45"),
  type="lower",
  insig = "blank") +  
    labs(title = "Correlation across numeric variables") 
```

# Regression Model

We are using linear regression OLS model for this machine learning task. 

## Data Split: Testing & Training

To train and test our model, we are splitting the existing data into 60% for training and 40% for testing. Since several neighborhoods only have 1 Airbnb in the area, we are keeping those data in the training set to avoid errors. However, we are aware that this results more neighbors having NAs.

```{r annual revenue regression, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}
annualrevenue <- merge(annualrevenue,listing.sf.neighbor2[c("id", "Buurt")], by = "id")
```

```{r}
#Split training and test set
annualrevenue <- annualrevenue%>% st_drop_geometry()
set.seed(31497)

inTrain <- caret::createDataPartition(
  y =  paste(annualrevenue$Buurt),
  p = .6, list = FALSE)

annualrevenue.training <- st_drop_geometry(annualrevenue)[inTrain,]
annualrevenue.test     <- st_drop_geometry(annualrevenue)[-inTrain,]
```

## Regression Results

The long table below shows the regression results from our model. The model has $R^2$ of 0.426 and most of the features we included appear to be significant. Although 0.426 may not be a high model for price prediction, we want to acknowledge the fact that Airbnb price may be more subjective, fluctuating, and unstable than house prices due to many unforeseeable factors. 

```{r}

reg.annualrevenue <- lm(price ~ ., data = st_drop_geometry(annualrevenue) %>% 
             dplyr::select(price, beds, bedrooms, bathrooms, accommodates,
                              pool, parking, kitchen, AC, fireplace,
                              room_type,property_type,bed_type, Buurt,
                              minimum_nights, convenienceshop.close, mall.close, museum.close,
                              plaza.close, supermarkets.close,
                              amenities.number,lagRevenue, metro.dist)) 

stargazer(reg.annualrevenue,
          type = "text",
          title ="Regression Output",
          single.row = TRUE,
          out.header = TRUE)

```

## MAPE (Mean Absolute Percentage Error)

By comparing the predicted price and actual price of our testing set, we summarized the errors in the table and map down below. Our model has a mean absolute percentage error of 29%, and it seems to be doing a better job in the central area than peripheral areas. As we will show in the following section, our model's general predictibility is higher in central areas, given the abundance of existing data concentrating in that area.

```{r annual revenue regression summ, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}

annualrev_predict_test <- annualrevenue.test %>%
  mutate(Prediction = predict(reg.annualrevenue, newdata = annualrevenue.test)) %>%
  mutate(Prediction = ifelse(Prediction > 0, Prediction, mean(annualrevenue.training$price)))%>%
  filter(price!=0)%>%
  drop_na(Prediction)%>%
  mutate(AE = abs(Prediction-price),
         APE = AE/Prediction)

test_result <- data.frame(MAE = c(mean(annualrev_predict_test$AE, na.rm=T)),
              MAPE = c(scales::percent(mean(annualrev_predict_test$APE, na.rm=T)))) 

test_result %>%
  kable(caption = "Figure 8. Mean absolute error and MAPE for a single test set")%>%
  kable_styling("striped", full_width = F)
```



```{r  annual revenue regression plot by Buurt, include=TRUE, echo = TRUE, message = FALSE, warning = FALSE}
palette5 <- c("#ffffd4", "#fed98e", "#fe9929", "#d95f0e", "#993404")

annualrev_predict_test%>%
  group_by(Buurt) %>%
  dplyr::summarize(mean.APE = mean(APE, na.rm = T)) %>%
  ungroup() %>% 
  left_join(neighbor2,by = "Buurt") %>%
    st_sf() %>%
    ggplot() + 
      geom_sf(aes(fill = mean.APE),colour = 'transparent') +
      scale_fill_gradient(low = palette5[1], high = palette5[5],
                          name = "MAPE") +
      labs(title = "Average Test Set MAPE"
           #,subtitle = "2019"
           ) +
      mapTheme()

```

# Cross Validation: LOGO (Leave One Group Out)

LOGO (Leave One Group Out) is a type of cross validation that is similar to K-fold but takes spatial aspects into consideration -- taking one neighborhood out at a time for cross validating. Since the airbnb location is critical in this project, we think LOGO would be a more suitable way for testing out our model. Here we use 481 'buurt (buurten)' (neighborhood in dutch) defined by the city. 

```{r results='hide', message=FALSE, warning=FALSE}


reg.vars <- c("beds", "bedrooms", "bathrooms", "accommodates",
                              "pool", "parking", "kitchen", "AC", "fireplace",
                              "room_type",  "bed_type",
                              "amenities.number","lagRevenue", "convenienceshop.close", "mall.close",
                              "museum.close",
                              "plaza.close", "supermarkets.close")

airbnb.location <- details.sf %>% dplyr::select(id)

annualrev_predict_test <- annualrev_predict_test %>% left_join(airbnb.location, by='id')
colnames(annualrev_predict_test)[1] =  "identifier"

reg.spatialCV <- crossValidate(
  dataset = annualrev_predict_test,
  id = "Buurt",
  dependentVariable = "price",
  indVariables = reg.vars) %>%
    dplyr::select(identifier = Buurt, price, Prediction, geometry)

```

```{r message=FALSE, warning=FALSE}

reg.spatialCV <-
  reg.spatialCV %>%
  mutate(Error = Prediction - price)

error_by_reg_and_fold <-
  reg.spatialCV  %>%
  group_by(identifier) %>%
  dplyr::summarize(Mean_error = mean(Error, na.rm=T),
                   MAE = mean(abs(Mean_error), na.rm=T),
                   SD_MAE = mean(abs(Mean_error), na.rm=T)) %>%
  ungroup()

st_drop_geometry(error_by_reg_and_fold) %>%
    dplyr::summarize(Mean_MAE = round(mean(MAE), 2),
              SD_MAE = round(sd(MAE), 2)) %>%
  kable() %>%
    kable_styling("striped", full_width = F) 

```

From the LOGO-CV result, our mean absolute error is 25.1 euro, with a 23.77 euro standard deviation. This means that on average our prediction could be 25.1 euro off, higher or lower. Given our predictability being ~42%, this is an expected and acceptable error to be observed.

Since earlier we observed a clustering in central areas, we are curious to see how our model performs in areas with more existing Airbnb vs. less. Hence we split neighborhoods into those with more than 50 Airbnb vs. less than 50, checked the respective mean absolute error for the high vs. low count groups, then plotted the mean error in each neighborhood. 


```{r}
#Counting per neighborhood
neighbourhoodCount <- annualrevenue %>%
  dplyr::count(Buurt)

#Joining to new spatial db
neighbourhoodHL <- neighbor2 %>%
  left_join(st_drop_geometry(neighbourhoodCount), by = "Buurt")%>%
  mutate(Airbnb1k = ifelse(n < 50, "Low", "High"))

#spatial join of the essential comparison data
st_join(error_by_reg_and_fold, neighbourhoodHL) %>% #fill in data frame with error column here
  group_by(Airbnb1k) %>%
  dplyr::summarize(mean.MAE = scales::percent(mean(MAE, na.rm = T))) %>% #fill in error column here
  st_drop_geometry() %>%
  spread(Airbnb1k, mean.MAE) %>%
  kable(caption = "<strong>Test set MAE within Neighborhoods Above or Below 50 Listings </strong>")%>%
  kable_styling()
```

The mean absolute error in area with higher count of Airbnb is significantly lower than the area with lower count, according to the data. The map below has lower-count areas in grey shade. By comparing shaded (lower count) to unshaded (higher count) areas, we can see that the shaded areas have more variation while the unshaded areas have mean errors closer to zero -- suggesting a better performance in higher count area. 

```{r}
colnames(error_by_reg_and_fold)[1] = "Buurt"

new <-
  neighbor2 %>% dplyr::select(Buurt, geometry) %>%
  left_join(st_drop_geometry(error_by_reg_and_fold), by = 'Buurt')
  

Low_Count_Boundary <-
  st_union(neighbourhoodHL %>% filter(Airbnb1k == 'Low'))

  ggplot() +
  geom_sf(data=new, aes(fill=Mean_error), size=0.3) +
  scale_fill_gradient(low = '#91bfdb', high = '#fc8d59', na.value = 'white', name = "Mean Error") +
  labs(title = "Mean Error (LOGO-CV)", subtitle = "Amsterdam, NL") + 
  geom_sf(data=Low_Count_Boundary, color="black", fill = mycol, size=0.7) + mapTheme() 


  mycol <- rgb(220,220,220, max = 255, alpha = 90, names = "blue50")
```

# Conclusion

In conclusion, our model gives a decent prediction for airbnb price in Amsterdam, although for it to be launched for our users, new hosts in Amsterdam, we would need more upgrades and feature engineering. From the results of cross validation, our model is better predicting price in areas with higher concentration of existing Airbnb in comparison to lower density areas, given the fact that more existing data is provided. We hope to improve this model / app and launch it for new hosts to utilize and better price their units in the near future. We will come insightful comments and feedback from Amsterdam locals. 

In addition, as this report demonstrate, many features incorporated in this model are linked specifically to Amsterdam, such as property type (given Amsterdam's boat house and other interesting architectural types) and specific amenities (such as fireplaces). At this stage, we are refraining from attempting to apply this model to other cities around the world. At the end of the day, each city (especially cities famous for tourism) have their unique selling points that attract tourists, and that is the reason why tourism and Airbnb exist in the first place. 

While our model is primarily built for new hosts, some of the analysis included in this report would also be helpful for policy makers as risk assessment. Although it is reasonable to try to develop all areas in the city, simply banning short-term rental in central areas may be detrimental to tourism yet not benefiting the peripheral areas of the city. By transforming this price-prediction model into a risk-prediction model, policy-makers will have more insights on which areas are potentially exploiting short-term rental. Policy-makers and planners can also work together to install amenities that are favorable by tourists, such as public transit and convenience shops, to direct flow of tourists to certain areas. In sum, information in this report could be helpful to policy makers as well. 

